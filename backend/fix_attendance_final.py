import os
import django
from django.db import connection

def force_fix_attendance():
    print("="*50)
    print("RUNNING EMERGENCY ATTENDANCE FIX")
    print("="*50)
    
    try:
        with connection.cursor() as cursor:
            # 1. Check if table exists
            cursor.execute("SHOW TABLES LIKE 'academic_attendance'")
            if not cursor.fetchone():
                print("Table academic_attendance not found. Skipping.")
                return

            # 2. List all indexes
            print("Scanning indexes...")
            cursor.execute("SHOW INDEX FROM academic_attendance")
            columns = [col[0] for col in cursor.description]
            indices = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            # 3. Identify bad unique indexes (not PRIMARY, and not the new v3 one)
            # The bad one reported is ...c422e8f2_uniq (generated by Django unique_together)
            # We want to keep ONLY indexes that involve 'date' in them, or PRIMARY/FKs
            # But SHOW INDEX provides rows per column.
            
            # Simpler approach: Drop the KNOWN BAD index by name if it exists
            bad_index_name = 'academic_attendance_student_id_course_offeri_c422e8f2_uniq'
            
            index_names = set(idx['Key_name'] for idx in indices)
            
            if bad_index_name in index_names:
                print(f"FOUND BAD INDEX: {bad_index_name}. Dropping it...")
                cursor.execute(f"DROP INDEX {bad_index_name} ON academic_attendance")
                print("Dropped successfully.")
            else:
                print(f"Bad index {bad_index_name} not found.")

            # 4. Also scan for ANY index that is UNIQUE and does NOT contain 'date'
            # Group keys
            index_map = {}
            for idx in indices:
                k = idx['Key_name']
                if k == 'PRIMARY': continue
                if k not in index_map: index_map[k] = {'unique': not idx['Non_unique'], 'cols': []}
                index_map[k]['cols'].append(idx['Column_name'])
                
            for name, meta in index_map.items():
                if meta['unique']:
                    cols = meta['cols']
                    # If this unique index does NOT include 'date', it is WRONG (unless it's just ID)
                    if 'date' not in cols and 'id' not in cols:
                        print(f"Found suspicious unique index '{name}' on {cols}. Dropping...")
                        try:
                            cursor.execute(f"DROP INDEX {name} ON academic_attendance")
                            print("Dropped.")
                        except Exception as e:
                            print(f"Error dropping {name}: {e}")

            # 5. Create Correct Index if missing
            # Only if no unique index on (student, course, date) exists
            has_correct = False
            for name, meta in index_map.items():
                if meta['unique'] and set(meta['cols']) == {'student_id', 'course_offering_id', 'date'}:
                    has_correct = True
                    break
            
            if not has_correct:
                print("Creating correct unique index (student, course, date)...")
                # First, ensure no duplicates exist
                cursor.execute("""
                    DELETE t1 FROM academic_attendance t1
                    INNER JOIN academic_attendance t2 
                    WHERE 
                        t1.id < t2.id AND 
                        t1.student_id = t2.student_id AND 
                        t1.course_offering_id = t2.course_offering_id AND 
                        t1.date = t2.date
                """)
                try:
                    cursor.execute("""
                        CREATE UNIQUE INDEX attendance_user_date_fix 
                        ON academic_attendance (student_id, course_offering_id, date)
                    """)
                    print("Created correct index.")
                except Exception as e:
                    print(f"Error creating correct index: {e}")

    except Exception as e:
        print(f"Fix failed with error: {e}")

    # 6. Check for pending migrations (Auto-Heal) - DIRECT SQL INJECTION
    print("Checking for missing schema changes...")
    try:
        with connection.cursor() as cursor:
            # Check and fix 'attendance' column
            cursor.execute("SHOW COLUMNS FROM academic_studentgrade LIKE 'attendance'")
            if not cursor.fetchone():
                print("Missing 'attendance' column detected! Injecting manually...")
                cursor.execute("ALTER TABLE academic_studentgrade ADD COLUMN attendance DECIMAL(5,2) NULL")
                print("Injected 'attendance' column.")
            
            # Check and fix 'quizzes' column
            cursor.execute("SHOW COLUMNS FROM academic_studentgrade LIKE 'quizzes'")
            if not cursor.fetchone():
                print("Missing 'quizzes' column detected! Injecting manually...")
                cursor.execute("ALTER TABLE academic_studentgrade ADD COLUMN quizzes DECIMAL(5,2) NULL")
                print("Injected 'quizzes' column.")
            
            print("Schema repair complete.")
            
    except Exception as e:
        print(f"Auto-heal failed: {e}")

    print("="*50)

if __name__ == "__main__":
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'bsu_backend.settings')
    django.setup()
    force_fix_attendance()
